// Copyright 2014-2017 Oxford University Innovation Limited and the authors of InfiniTAM

#include "ITMSceneReconstructionEngine_CUDA.h"

#include "../Shared/ITMSceneReconstructionEngine_Shared.h"
#include "../../../Objects/RenderStates/ITMRenderState_VH.h"
#include "../../../Utils/ITMCUDAUtils.h"

struct AllocationTempData {
  int noAllocatedVoxelEntries;
  int noAllocatedExcessEntries;
  int noVisibleEntries;
};

using namespace ITMLib;

namespace {

template<class TVoxel, bool stopMaxW>
__global__ void integrateIntoScene_device(TVoxel *localVBA,
                                          const ITMHashEntry *hashTable,
                                          int *noVisibleEntryIDs,
                                          const Vector4u *rgb,
                                          Vector2i rgbImgSize,
                                          const float *depth,
                                          const float *confidence,
                                          Vector2i imgSize,
                                          Matrix4f M_d,
                                          Matrix4f M_rgb,
                                          Vector4f projParams_d,
                                          Vector4f projParams_rgb,
                                          float _voxelSize,
                                          float mu,
                                          int maxW);

template<class TVoxel, bool stopMaxW>
__global__ void integrateIntoScene_device(TVoxel *voxelArray,
                                          const ITMPlainVoxelArray::ITMVoxelArrayInfo *arrayInfo,
                                          const Vector4u *rgb,
                                          Vector2i rgbImgSize,
                                          const float *depth,
                                          const float *confidence,
                                          Vector2i depthImgSize,
                                          Matrix4f M_d,
                                          Matrix4f M_rgb,
                                          Vector4f projParams_d,
                                          Vector4f projParams_rgb,
                                          float _voxelSize,
                                          float mu,
                                          int maxW);

__global__ void buildHashAllocAndVisibleType_device(uchar *entriesAllocType,
                                                    uchar *entriesVisibleType,
                                                    Vector4s *blockCoords,
                                                    const float *depth,
                                                    Matrix4f invM_d,
                                                    Vector4f projParams_d,
                                                    float mu,
                                                    Vector2i _imgSize,
                                                    float _voxelSize,
                                                    ITMHashEntry *hashTable,
                                                    float viewFrustum_min,
                                                    float viewFrustrum_max);

__global__ void allocateVoxelBlocksList_device(int *voxelAllocationList,
                                               int *excessAllocationList,
                                               ITMHashEntry *hashTable,
                                               int noTotalEntries,
                                               AllocationTempData *allocData,
                                               uchar *entriesAllocType,
                                               uchar *entriesVisibleType,
                                               Vector4s *blockCoords);

__global__ void reAllocateSwappedOutVoxelBlocks_device(int *voxelAllocationList,
                                                       ITMHashEntry *hashTable,
                                                       int noTotalEntries,
                                                       AllocationTempData *allocData,
                                                       uchar *entriesVisibleType);

__global__ void setToType3(uchar *entriesVisibleType, int *visibleEntryIDs, int noVisibleEntries);

template<bool useSwapping>
__global__ void buildVisibleList_device(ITMHashEntry *hashTable, ITMHashSwapState *swapStates, int noTotalEntries,
                                        int *visibleEntryIDs, AllocationTempData *allocData, uchar *entriesVisibleType,
                                        Matrix4f M_d, Vector4f projParams_d, Vector2i depthImgSize, float voxelSize);

}

// host methods

template<class TVoxel>
ITMSceneReconstructionEngine_CUDA<TVoxel, ITMVoxelBlockHash>::ITMSceneReconstructionEngine_CUDA(void) {
  ORcudaSafeCall(cudaMalloc((void **) &allocationTempData_device, sizeof(AllocationTempData)));
  ORcudaSafeCall(cudaMallocHost((void **) &allocationTempData_host, sizeof(AllocationTempData)));

  int noTotalEntries = ITMVoxelBlockHash::noTotalEntries;
  ORcudaSafeCall(cudaMalloc((void **) &entriesAllocType_device, noTotalEntries));
  ORcudaSafeCall(cudaMalloc((void **) &blockCoords_device, noTotalEntries * sizeof(Vector4s)));
}

template<class TVoxel>
ITMSceneReconstructionEngine_CUDA<TVoxel, ITMVoxelBlockHash>::~ITMSceneReconstructionEngine_CUDA(void) {
  ORcudaSafeCall(cudaFreeHost(allocationTempData_host));
  ORcudaSafeCall(cudaFree(allocationTempData_device));
  ORcudaSafeCall(cudaFree(entriesAllocType_device));
  ORcudaSafeCall(cudaFree(blockCoords_device));
}

template<class TVoxel>
void ITMSceneReconstructionEngine_CUDA<TVoxel, ITMVoxelBlockHash>::ResetScene(ITMScene<TVoxel,
                                                                                       ITMVoxelBlockHash> *scene) {
  int numBlocks = scene->index.getNumAllocatedVoxelBlocks();
  int blockSize = scene->index.getVoxelBlockSize();

  TVoxel *voxelBlocks_ptr = scene->localVBA.GetVoxelBlocks();
  memsetKernel<TVoxel>(voxelBlocks_ptr, TVoxel(), numBlocks * blockSize);
  int *vbaAllocationList_ptr = scene->localVBA.GetAllocationList();
  fillArrayKernel<int>(vbaAllocationList_ptr, numBlocks);
  scene->localVBA.lastFreeBlockId = numBlocks - 1;

  ITMHashEntry tmpEntry;
  memset(&tmpEntry, 0, sizeof(ITMHashEntry));
  tmpEntry.ptr = -2;
  ITMHashEntry *hashEntry_ptr = scene->index.GetEntries();
  memsetKernel<ITMHashEntry>(hashEntry_ptr, tmpEntry, scene->index.noTotalEntries);
  int *excessList_ptr = scene->index.GetExcessAllocationList();
  fillArrayKernel<int>(excessList_ptr, SDF_EXCESS_LIST_SIZE);

  scene->index.SetLastFreeExcessListId(SDF_EXCESS_LIST_SIZE - 1);
}

template <class TVoxel>
void ITMSceneReconstructionEngine_CUDA<TVoxel, ITMVoxelBlockHash>::AllocateSceneFromDepth(
    ITMScene<TVoxel, ITMVoxelBlockHash> *scene, const ITMView *view, const ITMTrackingState *trackingState,
    const ITMRenderState *renderState, bool onlyUpdateVisibleList, bool resetVisibleList) {
  //! 准备
  Vector2i depthImgSize = view->depth->noDims;      // 深度图分辨率
  float voxelSize = scene->sceneParams->voxelSize;

  ITMRenderState_VH *renderState_vh = (ITMRenderState_VH *) renderState;  // TODO: 父类转子类指针，最好用dynamic_cast
  if (resetVisibleList) renderState_vh->noVisibleEntries = 0;             // 需要的话，visible list置为零

  Matrix4f M_d = trackingState->pose_d->GetM(); // 深度图的位姿 和 它的逆
  Matrix4f invM_d;
  M_d.inv(invM_d);

  Vector4f projParams_d = view->calib.intrinsics_d.projectionParamsSimple.all;  // 深度图的相机内参
  Vector4f invProjParams_d = projParams_d;                                      // 相机内参的反投影，方便后面计算
  invProjParams_d.x = 1.0f / invProjParams_d.x;                                 // = 1/fx
  invProjParams_d.y = 1.0f / invProjParams_d.y;                                 // = 1/fy

  float mu = scene->sceneParams->mu;                                            // TSDF的截断值对应的距离

  float *depth = view->depth->GetData(MEMORYDEVICE_CUDA);                       // 深度图
  int *voxelAllocationList = scene->localVBA.GetAllocationList();               // VBA的空闲信息
  int *excessAllocationList = scene->index.GetExcessAllocationList();           // excess list的空闲信息
  ITMHashEntry *hashTable = scene->index.GetEntries();                          // hash table
  ITMHashSwapState *swapStates =                                                // 数据传输状态（host和device之间）
      scene->globalCache != NULL ? scene->globalCache->GetSwapStates(true) : 0;

  int noTotalEntries = scene->index.noTotalEntries;                             // entry总数。包含ordered + unordered

  int *visibleEntryIDs = renderState_vh->GetVisibleEntryIDs();                  // 当前视角下可见entrys的ID(数组)
  uchar *entriesVisibleType = renderState_vh->GetEntriesVisibleType();          // 所有entry的可见类型。长度noTotalEntries

  dim3 cudaBlockSizeHV(16, 16);
  dim3 gridSizeHV((int)ceil((float)depthImgSize.x / (float)cudaBlockSizeHV.x),  // ??? 提前定义有什么好处吗？？？
                  (int)ceil((float)depthImgSize.y / (float)cudaBlockSizeHV.y));

  dim3 cudaBlockSizeAL(256, 1);
  dim3 gridSizeAL((int)ceil((float)noTotalEntries / (float)cudaBlockSizeAL.x));

  dim3 cudaBlockSizeVS(256, 1);
  dim3 gridSizeVS((int)ceil((float)renderState_vh->noVisibleEntries / (float)cudaBlockSizeVS.x));

  float oneOverVoxelSize = 1.0f / (voxelSize * SDF_BLOCK_SIZE); // block实际边长的倒数，方便后面计算。应该叫BlockSize更合适
  // 杂碎的变量放一个struct，方便cuda中数据的操作
  AllocationTempData *tempData = (AllocationTempData *)allocationTempData_host; 
  tempData->noAllocatedVoxelEntries = scene->localVBA.lastFreeBlockId;            // VBA中剩余空位数
  tempData->noAllocatedExcessEntries = scene->index.GetLastFreeExcessListId();    // excess list中剩余空位数
  tempData->noVisibleEntries = 0;                                                 // 后续要找的可见的entry总数
  ORcudaSafeCall(
      cudaMemcpyAsync(allocationTempData_device, tempData, sizeof(AllocationTempData), cudaMemcpyHostToDevice));
  ORcudaSafeCall(cudaMemsetAsync(entriesAllocType_device, 0, sizeof(unsigned char) * noTotalEntries));
  //! 将上一帧可见但还没拷贝出去的entry的可见类型都值为3 ???
  if (gridSizeVS.x > 0) {
    setToType3<<<gridSizeVS, cudaBlockSizeVS>>>(entriesVisibleType, visibleEntryIDs, renderState_vh->noVisibleEntries);
    ORcudaKernelCheck;
  }
  //! 查看每个像素对应三维点附近所有block的alloction和可见情况
  buildHashAllocAndVisibleType_device<<<gridSizeHV, cudaBlockSizeHV>>>(
      entriesAllocType_device, entriesVisibleType, blockCoords_device, depth, invM_d, invProjParams_d, mu, depthImgSize,
      oneOverVoxelSize, hashTable, scene->sceneParams->viewFrustum_min, scene->sceneParams->viewFrustum_max);
  ORcudaKernelCheck;

  bool useSwapping = scene->globalCache != NULL;
  if (onlyUpdateVisibleList)  // ???为啥只更新可见列表的话，关闭swap？？？
    useSwapping = false;
  //! 对于所有的entry，对于上面找到的需要分配的block进行分配。推荐参考文件“说明材料/localVBA.pptx”
  if (!onlyUpdateVisibleList) {
    allocateVoxelBlocksList_device<<<gridSizeAL, cudaBlockSizeAL>>>(
        voxelAllocationList, excessAllocationList, hashTable, noTotalEntries,
        (AllocationTempData *)allocationTempData_device, entriesAllocType_device, entriesVisibleType,
        blockCoords_device);
    ORcudaKernelCheck;
  }
  //! 找到所有entry中可见的 build visible list
  if (useSwapping) {  // 开启swap，可见 但 不止在显存上，标记一下需要合并
    buildVisibleList_device<true><<<gridSizeAL, cudaBlockSizeAL>>>(
        hashTable, swapStates, noTotalEntries, visibleEntryIDs, (AllocationTempData *)allocationTempData_device,
        entriesVisibleType, M_d, projParams_d, depthImgSize, voxelSize);
    ORcudaKernelCheck;
  } else {
    buildVisibleList_device<false><<<gridSizeAL, cudaBlockSizeAL>>>(
        hashTable, swapStates, noTotalEntries, visibleEntryIDs, (AllocationTempData *)allocationTempData_device,
        entriesVisibleType, M_d, projParams_d, depthImgSize, voxelSize);
    ORcudaKernelCheck;
  }
  //! 开启swap，将所有entry中可见但是没有分配空间的分配一下 
  // TODO：之前buildHashAllocAndVisibleTypePP不是都分配过了吗？？？还有什么情况会没有分配过？？？
  if (useSwapping) {
    reAllocateSwappedOutVoxelBlocks_device<<<gridSizeAL, cudaBlockSizeAL>>>(
        voxelAllocationList, hashTable, noTotalEntries, (AllocationTempData *)allocationTempData_device,
        entriesVisibleType);
    ORcudaKernelCheck;
  }

  ORcudaSafeCall(cudaMemcpy(tempData, allocationTempData_device, sizeof(AllocationTempData), cudaMemcpyDeviceToHost));
  renderState_vh->noVisibleEntries = tempData->noVisibleEntries;
  scene->localVBA.lastFreeBlockId = tempData->noAllocatedVoxelEntries;
  scene->index.SetLastFreeExcessListId(tempData->noAllocatedExcessEntries);
}

template <class TVoxel> // TODO: 下次从这儿开始
void ITMSceneReconstructionEngine_CUDA<TVoxel, ITMVoxelBlockHash>::IntegrateIntoScene(
    ITMScene<TVoxel, ITMVoxelBlockHash> *scene, const ITMView *view, const ITMTrackingState *trackingState,
    const ITMRenderState *renderState) {
  Vector2i rgbImgSize = view->rgb->noDims;
  Vector2i depthImgSize = view->depth->noDims;
  float voxelSize = scene->sceneParams->voxelSize;

  Matrix4f M_d, M_rgb;
  Vector4f projParams_d, projParams_rgb;

  ITMRenderState_VH *renderState_vh = (ITMRenderState_VH *) renderState;
  if (renderState_vh->noVisibleEntries == 0) return;

  M_d = trackingState->pose_d->GetM();
  if (TVoxel::hasColorInformation) M_rgb = view->calib.trafo_rgb_to_depth.calib_inv * M_d;

  projParams_d = view->calib.intrinsics_d.projectionParamsSimple.all;
  projParams_rgb = view->calib.intrinsics_rgb.projectionParamsSimple.all;

  float mu = scene->sceneParams->mu;
  int maxW = scene->sceneParams->maxW;

  float *depth = view->depth->GetData(MEMORYDEVICE_CUDA);
  float *confidence = view->depthConfidence->GetData(MEMORYDEVICE_CUDA);
  Vector4u *rgb = view->rgb->GetData(MEMORYDEVICE_CUDA);
  TVoxel *localVBA = scene->localVBA.GetVoxelBlocks();
  ITMHashEntry *hashTable = scene->index.GetEntries();

  int *visibleEntryIDs = renderState_vh->GetVisibleEntryIDs();

  dim3 cudaBlockSize(SDF_BLOCK_SIZE, SDF_BLOCK_SIZE, SDF_BLOCK_SIZE);
  dim3 gridSize(renderState_vh->noVisibleEntries);

  if (scene->sceneParams->stopIntegratingAtMaxW) {
    integrateIntoScene_device<TVoxel, true> << < gridSize, cudaBlockSize >> >(localVBA, hashTable, visibleEntryIDs,
        rgb, rgbImgSize, depth, confidence, depthImgSize, M_d, M_rgb, projParams_d, projParams_rgb, voxelSize, mu, maxW);
    ORcudaKernelCheck;
  } else {
    integrateIntoScene_device<TVoxel, false> << < gridSize, cudaBlockSize >> >(localVBA, hashTable, visibleEntryIDs,
        rgb, rgbImgSize, depth, confidence, depthImgSize, M_d, M_rgb, projParams_d, projParams_rgb, voxelSize, mu, maxW);
    ORcudaKernelCheck;
  }
}

// plain voxel array

template<class TVoxel>
void ITMSceneReconstructionEngine_CUDA<TVoxel, ITMPlainVoxelArray>::ResetScene(ITMScene<TVoxel,
                                                                                        ITMPlainVoxelArray> *scene) {
  int numBlocks = scene->index.getNumAllocatedVoxelBlocks();
  int blockSize = scene->index.getVoxelBlockSize();

  TVoxel *voxelBlocks_ptr = scene->localVBA.GetVoxelBlocks();
  memsetKernel<TVoxel>(voxelBlocks_ptr, TVoxel(), numBlocks * blockSize);
  int *vbaAllocationList_ptr = scene->localVBA.GetAllocationList();
  fillArrayKernel<int>(vbaAllocationList_ptr, numBlocks);
  scene->localVBA.lastFreeBlockId = numBlocks - 1;
}

template <class TVoxel>
void ITMSceneReconstructionEngine_CUDA<TVoxel, ITMPlainVoxelArray>::AllocateSceneFromDepth(
    ITMScene<TVoxel, ITMPlainVoxelArray> *scene, const ITMView *view, const ITMTrackingState *trackingState,
    const ITMRenderState *renderState, bool onlyUpdateVisibleList, bool resetVisibleList) {}

template <class TVoxel>
void ITMSceneReconstructionEngine_CUDA<TVoxel, ITMPlainVoxelArray>::IntegrateIntoScene(
    ITMScene<TVoxel, ITMPlainVoxelArray> *scene, const ITMView *view, const ITMTrackingState *trackingState,
    const ITMRenderState *renderState) {
  Vector2i rgbImgSize = view->rgb->noDims;
  Vector2i depthImgSize = view->depth->noDims;
  float voxelSize = scene->sceneParams->voxelSize;

  Matrix4f M_d, M_rgb;
  Vector4f projParams_d, projParams_rgb;

  M_d = trackingState->pose_d->GetM();
  if (TVoxel::hasColorInformation) M_rgb = view->calib.trafo_rgb_to_depth.calib_inv * M_d;

  projParams_d = view->calib.intrinsics_d.projectionParamsSimple.all;
  projParams_rgb = view->calib.intrinsics_rgb.projectionParamsSimple.all;

  float mu = scene->sceneParams->mu;
  int maxW = scene->sceneParams->maxW;

  float *depth = view->depth->GetData(MEMORYDEVICE_CUDA);
  Vector4u *rgb = view->rgb->GetData(MEMORYDEVICE_CUDA);
  TVoxel *localVBA = scene->localVBA.GetVoxelBlocks();
  const ITMPlainVoxelArray::ITMVoxelArrayInfo *arrayInfo = scene->index.getIndexData();

  dim3 cudaBlockSize(8, 8, 8);
  dim3 gridSize(scene->index.getVolumeSize().x / cudaBlockSize.x,
                scene->index.getVolumeSize().y / cudaBlockSize.y,
                scene->index.getVolumeSize().z / cudaBlockSize.z);

  if (scene->sceneParams->stopIntegratingAtMaxW) {
    integrateIntoScene_device<TVoxel, true> << < gridSize, cudaBlockSize >> >(localVBA, arrayInfo,
        rgb, rgbImgSize, depth, depthImgSize, M_d, M_rgb, projParams_d, projParams_rgb, voxelSize, mu, maxW);
    ORcudaKernelCheck;
  } else {
    integrateIntoScene_device<TVoxel, false> << < gridSize, cudaBlockSize >> >(localVBA, arrayInfo,
        rgb, rgbImgSize, depth, depthImgSize, M_d, M_rgb, projParams_d, projParams_rgb, voxelSize, mu, maxW);
    ORcudaKernelCheck;
  }
}

namespace {

// device functions

template <class TVoxel, bool stopMaxW>
__global__ void integrateIntoScene_device(TVoxel *voxelArray, const ITMPlainVoxelArray::ITMVoxelArrayInfo *arrayInfo,
                                          const Vector4u *rgb, Vector2i rgbImgSize, const float *depth,
                                          const float *confidence, Vector2i depthImgSize, Matrix4f M_d, Matrix4f M_rgb,
                                          Vector4f projParams_d, Vector4f projParams_rgb, float _voxelSize, float mu,
                                          int maxW) {
  int x = blockIdx.x * blockDim.x + threadIdx.x;
  int y = blockIdx.y * blockDim.y + threadIdx.y;
  int z = blockIdx.z * blockDim.z + threadIdx.z;

  Vector4f pt_model;
  int locId = x + y * arrayInfo->size.x + z * arrayInfo->size.x * arrayInfo->size.y;

  if (stopMaxW)
    if (voxelArray[locId].w_depth == maxW)
      return;
  //	if (approximateIntegration) if (voxelArray[locId].w_depth != 0) return;

  pt_model.x = (float)(x + arrayInfo->offset.x) * _voxelSize;
  pt_model.y = (float)(y + arrayInfo->offset.y) * _voxelSize;
  pt_model.z = (float)(z + arrayInfo->offset.z) * _voxelSize;
  pt_model.w = 1.0f;

  ComputeUpdatedVoxelInfo<TVoxel::hasColorInformation, TVoxel::hasConfidenceInformation, TVoxel>::compute(
      voxelArray[locId], pt_model, M_d, projParams_d, M_rgb, projParams_rgb, mu, maxW, depth, confidence, depthImgSize,
      rgb, rgbImgSize);
}

template <class TVoxel, bool stopMaxW>
__global__ void integrateIntoScene_device(TVoxel *localVBA, const ITMHashEntry *hashTable, int *visibleEntryIDs,
                                          const Vector4u *rgb, Vector2i rgbImgSize, const float *depth,
                                          const float *confidence, Vector2i depthImgSize, Matrix4f M_d, Matrix4f M_rgb,
                                          Vector4f projParams_d, Vector4f projParams_rgb, float _voxelSize, float mu,
                                          int maxW) {
  int entryId = visibleEntryIDs[blockIdx.x];
  const ITMHashEntry &currentHashEntry = hashTable[entryId];
  if (currentHashEntry.ptr < 0) return;

  Vector3i globalPos = currentHashEntry.pos.toInt() * SDF_BLOCK_SIZE;

  TVoxel *localVoxelBlock = &(localVBA[currentHashEntry.ptr * SDF_BLOCK_SIZE3]);

  int x = threadIdx.x, y = threadIdx.y, z = threadIdx.z;

  int locId = x + y * SDF_BLOCK_SIZE + z * SDF_BLOCK_SIZE * SDF_BLOCK_SIZE;

  if (stopMaxW)
    if (localVoxelBlock[locId].w_depth == maxW)
      return;
  // if (approximateIntegration) if (localVoxelBlock[locId].w_depth != 0) return;
  
  Vector4f pt_model;
  pt_model.x = (float)(globalPos.x + x) * _voxelSize;
  pt_model.y = (float)(globalPos.y + y) * _voxelSize;
  pt_model.z = (float)(globalPos.z + z) * _voxelSize;
  pt_model.w = 1.0f;

  ComputeUpdatedVoxelInfo<TVoxel::hasColorInformation, TVoxel::hasConfidenceInformation, TVoxel>::compute(
      localVoxelBlock[locId], pt_model, M_d, projParams_d, M_rgb, projParams_rgb, mu, maxW, depth, confidence,
      depthImgSize, rgb, rgbImgSize);
}
/**
 * @brief 寻找每个像素对应三维点附近所有block，查看alloction和可见情况
 * @param[out] entriesAllocType entry存放位置。=1为order entry，=2为excess list
 * @param[out] entriesVisibleType 所有entry的可见情况。=1是正常可见，=2是可见但是被swap out
 * @param[out] blockCoords 没有分配的entry会记录block坐标（short类型）
 * @param[in] depth 深度图
 * @param[in] invM_d 深度图位姿的逆（local to world？？？）
 * @param[in] projParams_d 深度图相机内参的反投影
 * @param[in] mu TSDF的截断值对应的距离
 * @param[in] _imgSize 图像分辨率（x*y)
 * @param[in] _voxelSize block实际边长的倒数。不应该叫VoxelSize
 * @param[in] hashTable 
 * @param[in] viewFrustum_min 视锥中最小深度
 * @param[in] viewFrustum_max 视锥中最大深度
 * @note 单帧内出现哈希冲突咋办？？？
 */
__global__ void buildHashAllocAndVisibleType_device(uchar *entriesAllocType, uchar *entriesVisibleType,
                                                    Vector4s *blockCoords, const float *depth, Matrix4f invM_d,
                                                    Vector4f projParams_d, float mu, Vector2i _imgSize,
                                                    float _voxelSize, ITMHashEntry *hashTable, float viewFrustum_min,
                                                    float viewFrustum_max) {
  int x = threadIdx.x + blockIdx.x * blockDim.x, y = threadIdx.y + blockIdx.y * blockDim.y;
  if (x > _imgSize.x - 1 || y > _imgSize.y - 1) return;

  buildHashAllocAndVisibleTypePP(entriesAllocType, entriesVisibleType, x, y, blockCoords, depth, invM_d,
                                 projParams_d, mu, _imgSize, _voxelSize, hashTable, viewFrustum_min, viewFrustum_max);
}
/**
 * @brief 将所有在visibleEntryIDs中的entry的visible type设置为3
 * @details 设置为3是为了表示当前entry在之前可见，这样在后续的查找中可以区分
 * @param[out] entriesVisibleType 所有entry的可见类型。长度noTotalEntries
 * @param[in] visibleEntryIDs     之前的可见entry的id（数组）
 * @param[in] noVisibleEntries    之前的可见entry的总数
 */
__global__ void setToType3(uchar *entriesVisibleType, int *visibleEntryIDs, int noVisibleEntries) {
  int entryId = threadIdx.x + blockIdx.x * blockDim.x;
  if (entryId > noVisibleEntries - 1) return;
  entriesVisibleType[visibleEntryIDs[entryId]] = 3;
}
/**
 * @brief 遍历所有entry，给需要分配的block分配内存
 * @param[in] voxelAllocationList VBA的空闲信息
 * @param[in] excessAllocationList excess list的空闲信息
 * @param[out] hashTable 
 * @param[in] noTotalEntries entry总数
 * @param[in, out] allocData 杂碎变量的集合。包含 VBA中剩余空位数、excess list中剩余空位数、可见的entry总数
 * @param[in] entriesAllocType 要分配的空间类型（其实是位置）。=1存放于order list，=2存放于unorder(excess) list
 * @param[out] entriesVisibleType 所有entry的可见类型。长度noTotalEntries
 * @param[in] blockCoords 每个entry对应的block坐标
 */
__global__ void allocateVoxelBlocksList_device(int *voxelAllocationList, int *excessAllocationList,
                                               ITMHashEntry *hashTable, int noTotalEntries,
                                               AllocationTempData *allocData, uchar *entriesAllocType,
                                               uchar *entriesVisibleType, Vector4s *blockCoords) {
  int targetIdx = threadIdx.x + blockIdx.x * blockDim.x;
  if (targetIdx > noTotalEntries - 1) return;

  int vbaIdx, exlIdx; // 用寄存器更快
  switch (entriesAllocType[targetIdx]) {  // TODO: 将不同case中的相同操作拿出来放一起，减少分化
  case 1: //! 需要分配到ordered list。needs allocation, fits in the ordered list
    vbaIdx = atomicSub(&allocData->noAllocatedVoxelEntries, 1); // --是因为VBA是从后往前存的
    // TODO: 应该判断allocData->noAllocatedVoxelEntries>=1以减少原子操作？但是不能保证对比了后，空间不会被别人抢去。有没有原子比大小？
    if (vbaIdx >= 0) {  // 剩余空间充足。there is room in the voxel block array
      Vector4s pt_block_all = blockCoords[targetIdx]; // 取出buildHashAllocAndVisibleTypePP中记录的block坐标

      ITMHashEntry hashEntry;
      hashEntry.pos.x = pt_block_all.x;
      hashEntry.pos.y = pt_block_all.y;
      hashEntry.pos.z = pt_block_all.z;
      hashEntry.ptr = voxelAllocationList[vbaIdx];  // NOTE：voxelAllocationList[vbaIdx]就是VBA中的空闲位置
      hashEntry.offset = 0;   // TODO: 设置成-1更合理。这样之后遇到冲突了，offset就不用+1或者-1了

      hashTable[targetIdx] = hashEntry;             // hash table中记录entry信息
    } else {            // 剩余空间不足
      // Mark entry as not visible since we couldn't allocate it but buildHashAllocAndVisibleTypePP changed its state.
      entriesVisibleType[targetIdx] = 0;    // 无法allocate，需要设置visible=false

      // 剩余空间不足了，要把刚刚分配的再还回去。Restore the previous value to avoid leaks.
      atomicAdd(&allocData->noAllocatedVoxelEntries, 1);
    }
    break;

  case 2: //! 需要分配到excess list（即unordered entry）。 needs allocation in the excess list
    vbaIdx = atomicSub(&allocData->noAllocatedVoxelEntries, 1);
    exlIdx = atomicSub(&allocData->noAllocatedExcessEntries, 1);

    if (vbaIdx >= 0 && exlIdx >= 0) { // VBA和excess list都有空位。there is room in the voxel block array and excess list
      Vector4s pt_block_all = blockCoords[targetIdx]; // 取出block坐标

      ITMHashEntry hashEntry;
      hashEntry.pos.x = pt_block_all.x;
      hashEntry.pos.y = pt_block_all.y;
      hashEntry.pos.z = pt_block_all.z;
      hashEntry.ptr = voxelAllocationList[vbaIdx];  // NOTE：voxelAllocationList[vbaIdx]就是VBA中的空闲位置
      hashEntry.offset = 0; // TODO: 设置成-1更合理。这样之后遇到冲突了，offset就不用+1或者-1了

      int exlOffset = excessAllocationList[exlIdx]; // 跟voxelAllocationList同理，找到excess list的空闲位置

      hashTable[targetIdx].offset = exlOffset + 1;      // +1是因为上面offset = 0，后面使用的时候会-1，判断的时候会跟1比较
                                                        // connect to child
      hashTable[SDF_BUCKET_NUM + exlOffset] = hashEntry;  // SDF_BUCKET_NUM之后的是excess list
                                                          // add child to the excess list
      entriesVisibleType[SDF_BUCKET_NUM + exlOffset] = 1; // ∵buildHashAllocAndVisibleTypePP没对unorder entry标记可见
                                                          // make child visible
    } else {                          // VBA和excess list有一个没空位了
      // No need to mark the entry as not visible since buildHashAllocAndVisibleTypePP did not mark it.
      // Restore the previous values to avoid leaks.
      atomicAdd(&allocData->noAllocatedVoxelEntries, 1);
      atomicAdd(&allocData->noAllocatedExcessEntries, 1);
    }
    break;
  }
}
/**
 * 将所有entry中可见但是没有分配空间的分配一下  // TODO：buildHashAllocAndVisibleTypePP不是都分配过了吗？？？什么情况会没有分配过？
 * @param[in] voxelAllocationList VBA的空闲信息
 * @param[in, out] hashTable
 * @param[in] noTotalEntries entry总数
 * @param[in, out] allocData 杂碎变量的集合。包含 VBA中剩余空位数、excess list中剩余空位数、可见的entry总数
 * @param[in] entriesVisibleType 所有entry的可见类型  // TODO: 这里输入visibleEntryIDs更好吧？？？
 */
__global__ void reAllocateSwappedOutVoxelBlocks_device(int *voxelAllocationList, ITMHashEntry *hashTable,
                                                       int noTotalEntries, AllocationTempData *allocData, 
                                                       /*int *noAllocatedVoxelEntries,*/ uchar *entriesVisibleType) {
  int targetIdx = threadIdx.x + blockIdx.x * blockDim.x;
  if (targetIdx > noTotalEntries - 1) return;

  int vbaIdx;
  int hashEntry_ptr = hashTable[targetIdx].ptr;

  if (entriesVisibleType[targetIdx] > 0 && hashEntry_ptr == -1) {   // 可见但是没有分配空间???
    //it is visible and has been previously allocated inside the hash, but deallocated from VBA
    vbaIdx = atomicSub(&allocData->noAllocatedVoxelEntries, 1);
    if (vbaIdx >= 0)  // 还有剩余空间
      hashTable[targetIdx].ptr = voxelAllocationList[vbaIdx]; // NOTE：所谓分配内存，就是将entry的ptr取值为VBA的空闲位置的下标
    else              // 没有剩余空间了，还回去
      atomicAdd(&allocData->noAllocatedVoxelEntries, 1);
  }
}
/**
 * @brief 再次检查entry的可见性 && 更新swap status && 汇总所有可见block的entry id
 * @details 只查看“之前可见 但 现在不可见”的可见性；“更新swap status”只在开启swap的情况下可用
 * @tparam useSwapping 是否支持交换内存-显存数据。C++的非类型模板参数https://blog.csdn.net/lanchunhui/article/details/49634077
 * @param[in] hashTable 
 * @param[in, out] swapStates 所有entry的数据传输状态，只有开启swap功能的情况下才会用
 * @param[in] noTotalEntries entry总数
 * @param[out] visibleEntryIDs 所有可见block的entry id
 * @param[in, out] allocData 杂碎变量的集合。包含 VBA中剩余空位数、excess list中剩余空位数、可见的entry总数
 * @param[out] entriesVisibleType 所有entry的可见类型
 * @param[in] M_d world to local的变换矩阵
 * @param[in] projParams_d 投影的相机内参
 * @param[in] depthImgSize 深度图的图像大小
 * @param[in] voxelSize voxel的实际尺寸。单位米
 */
template<bool useSwapping>
__global__ void buildVisibleList_device(ITMHashEntry *hashTable, ITMHashSwapState *swapStates, int noTotalEntries,
                                        int *visibleEntryIDs, AllocationTempData *allocData, uchar *entriesVisibleType,
                                        Matrix4f M_d, Vector4f projParams_d, Vector2i depthImgSize, float voxelSize) {
  int targetIdx = threadIdx.x + blockIdx.x * blockDim.x;
  if (targetIdx > noTotalEntries - 1) return;

  __shared__ bool shouldPrefix;
  shouldPrefix = false;
  __syncthreads();

  unsigned char hashVisibleType = entriesVisibleType[targetIdx];
  const ITMHashEntry &hashEntry = hashTable[targetIdx];
  //! 之前可见 但 现在不可见的再检查一下可见性
  if (hashVisibleType == 3) {         // =3说明之前可见，但是现在不可见
    bool isVisibleEnlarged, isVisible;
    if (useSwapping) {  // 有swap的会用更大（扩大1/8）的image size查看可见性。 ∵要保证device和host的数据无缝融合？？？
      checkBlockVisibility<true>(isVisible, isVisibleEnlarged, hashEntry.pos, M_d, projParams_d, voxelSize,
                                 depthImgSize);
      if (!isVisibleEnlarged) hashVisibleType = 0;  // 搜索后确定不可见
    } else {            // 没有swap用正常的image size查看可见性
      checkBlockVisibility<false>(isVisible, isVisibleEnlarged, hashEntry.pos, M_d, projParams_d, voxelSize,
                                  depthImgSize);
      if (!isVisible) hashVisibleType = 0;          // 搜索后确定不可见
    }
    entriesVisibleType[targetIdx] = hashVisibleType;
  }

  //! 开启swap，可见 但 不只在显存上，标记一下需要合并
  if (useSwapping) {
    if (hashVisibleType > 0 && swapStates[targetIdx].state != 2)
      swapStates[targetIdx].state = 1;  // =1说明数据同时在内存和显存上，尚未合并
  }
  //! 通过前缀和来找到 所需entry在最后数组中的位置，然后记录
  if (hashVisibleType > 0) shouldPrefix = true;
  __syncthreads();
  if (shouldPrefix) {
    int offset = computePrefixSum_device<int>(hashVisibleType > 0, &allocData->noVisibleEntries,
                                              blockDim.x * blockDim.y, threadIdx.x);
    if (offset != -1) visibleEntryIDs[offset] = targetIdx;  // 记录entry id到数组中
  }

#if 0   // TODO: active list是啥？？？论文中没有
  // "active list": blocks that have new information from depth image
  // currently not used...
  __syncthreads();

  if (shouldPrefix)
  {
      int offset = computePrefixSum_device<int>(hashVisibleType == 1, noActiveEntries, blockDim.x * blockDim.y, threadIdx.x);
      if (offset != -1) activeEntryIDs[offset] = targetIdx;
  }
#endif
}
}
