# 概念
- engine：表示各种接口？？？
- view：表示输入图片
- view frustum：视锥，或者叫平截头体
- render：在voxel表示的场景中，就是raycasting。那surfel呢？？？
- voxel size: 每个voxel在真实世界下的边长，单位为米
- block size: block中每一边有几个voxel，默认是8。即一个block中的voxel数量为8\*8\*8
- voxel坐标 = 真实坐标/voxel size
- block坐标 = voxel坐标/block size
- ordered entries && unordered entries && excess list：见论文的Fig2，ordered entries就是直接通过哈希值索引找到的entry数组；unordered entries(excess list 或者 overflow list)是为了解决哈希冲突额外设立的entry数组，通过 哈希值找到的ordered entry中的offset来索引。
    - 需要注意的是，ordered + unordered entry的数量 = SDF_BUCKET_NUM，是比device上的voxel block array的长度（=SDF_LOCAL_BLOCK_NUM）长的
- allocate && allocattion：分配空间的意思。voxel hashing对整个空间划分block后没有马上分配空间，而是扫描到东西了后才分配。对于CPU，空间指的是内存；对于GPU，空间指的是显存（当然可能会被转移到内存上）
- device && host: 如果使用了GPU，一般来说device指GPU（或者显存）、host指CPU（或者内存）；如果只用了CPU，一般来说device指内存，host指硬盘，但是代码中device和host都是内存（应该是还没实现完）
- VBA：voxel block array的缩写。
    - 说是block array，其实本质上是个voxel array，通过$i*\text{SDF\_BLOCK\_SIZE3}$即可在VBA中找到每个block的起始位置
    - localVBA（即device上的VBA）的长度为SDF_LOCAL_BLOCK_NUM，是小于hash table中entry的数量的
# 代码跟论文的区别

| 论文                                                         | 代码                                                       |
| ------------------------------------------------------------ | ---------------------------------------------------------- |
| Fig1中的数据                                                 |                                                            |
| Fig4中说的顺序是integration => swap in => raycast => swap out | 代码中的顺序是ntegration => swap in => swap out => raycast |
|                                                              |                                                            |

# 命名规则

## 变量

- 采用 小驼峰命名法
- `no`开头的变量：表示数量
- `_local`结尾的变量：表示存放在device上
- `_global`结尾的变量：表示存放在host上

# 文件命名规则

- 


# 文件夹说明
├── Apps：InfiniTAM的demo程序
│   ├── android
│   ├── InfiniTAM
│   ├── InfiniTAM_cli
│   └── iOS
├── cmake：
├── FernRelocLib：单独将基于随机蕨的重定位算法弄成了一个库
├── Files：存放相机内参文件
│   ├── PrimeSense
│   └── Teddy
├── images：存放用于重建的图像序列。
├── InputSource：输入相关代码。比如从各种RGBD相机读取数据，或者从图片序列、视频流读取数据等
├── ITMLib
│   ├── Core
│   ├── Engines
│   │   ├── LowLevel
│   │   ├── Meshing
│   │   ├── MultiScene
│   │   ├── Reconstruction
│   │   ├── Swapping: device端和host端之间的数据交换。对应论文的。有CPU和GPU（CUDA）版本。推荐别看CPU的，因为就是内存的数据从自己拷贝到自己，没意思！GPU版的，会将暂时不可见的数据从显存挪到内存中，从而增加重建范围（这才是swap的意义
│   │   ├── ViewBuilding
│   │   └── Visualisation
│   ├── Objects
│   │   ├── Camera
│   │   ├── Meshing
│   │   ├── Misc
│   │   ├── RenderStates
│   │   ├── Scene
│   │   ├── Tracking
│   │   └── Views
│   ├── Trackers
│   └── Utils
├── MiniSlamGraphLib
└── ORUtils

一些文件夹下面

# 注释进度

- [ ] Apps
    - [ ] InfiniTAM
- [ ] FernRelocLib
- [ ] InputSource
- [ ] ITMLib
    - [ ] Core
    - [ ] Engines
        - [x] LowLevel
        - [ ] Meshing
        - [ ] MultiScene
        - [x] Reconstruction
        - [x] Swapping
        - [x] ViewBuilding
        - [ ] Visualisation
    - [ ] Objects
        - [ ] Camera
        - [ ] Meshing
        - [ ] Misc
        - [ ] RenderStates
        - [ ] Scene
        - [ ] Tracking
        - [ ] Views
    - [ ] Trackers
    - [ ] Utils
- [ ] MiniSlamGraphLib
- [ ] ORUtils